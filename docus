Image

The Next.js Image component extends the HTML <img> element for automatic image optimization.

app/page.js

import Image from 'next/image'
 
export default function Page() {
  return (
    <Image
      src="/profile.png"
      width={500}
      height={500}
      alt="Picture of the author"
    />
  )
}
Good to know: If you are using a version of Next.js prior to 13, you'll want to use the next/legacy/image documentation since the component was renamed.
Reference

Props

The following props are available:

Prop	Example	Type	Status
src	src="/profile.png"	String	Required
alt	alt="Picture of the author"	String	Required
width	width={500}	Integer (px)	-
height	height={500}	Integer (px)	-
fill	fill={true}	Boolean	-
loader	loader={imageLoader}	Function	-
sizes	sizes="(max-width: 768px) 100vw, 33vw"	String	-
quality	quality={80}	Integer (1-100)	-
priority	priority={true}	Boolean	-
placeholder	placeholder="blur"	String	-
style	style={{objectFit: "contain"}}	Object	-
onLoadingComplete	onLoadingComplete={img => done())}	Function	Deprecated
onLoad	onLoad={event => done())}	Function	-
onError	onError(event => fail()}	Function	-
loading	loading="lazy"	String	-
blurDataURL	blurDataURL="data:image/jpeg..."	String	-
overrideSrc	overrideSrc="/seo.png"	String	-
src

The source of the image. Can be one of the following:

An internal path string.


<Image src="/profile.png" />
An absolute external URL (must be configured with remotePatterns).


<Image src="https://example.com/profile.png" />
A static import.


import profile from './profile.png'
 
export default function Page() {
  return <Image src={profile} />
}
alt

The alt property is used to describe the image for screen readers and search engines. It is also the fallback text if images have been disabled or an error occurs while loading the image.

It should contain text that could replace the image without changing the meaning of the page. It is not meant to supplement the image and should not repeat information that is already provided in the captions above or below the image.

If the image is purely decorative or not intended for the user, the alt property should be an empty string (alt="").

Learn more about image accessibility guidelines.
width and height

The width and height properties represent the intrinsic image size in pixels. This property is used to infer the correct aspect ratio used by browsers to reserve space for the image and avoid layout shift during loading. It does not determine the rendered size of the image, which is controlled by CSS.


<Image src="/profile.png" width={500} height={500} />
You must set both width and height properties unless:

The image is statically imported.
The image has the fill property
If the height and width are unknown, we recommend using the fill property.

fill

A boolean that causes the image to expand to the size of the parent element.


<Image src="/profile.png" fill={true} />
Positioning:

The parent element must assign position: "relative", "fixed", "absolute".
By default, the <img> element uses position: "absolute".
Object Fit:

If no styles are applied to the image, the image will stretch to fit the container. You can use objectFit to control cropping and scaling.

"contain": The image will be scaled down to fit the container and preserve aspect ratio.
"cover": The image will fill the container and be cropped.
Learn more about position and object-fit.
loader

A custom function used to generate the image URL. The function receives the following parameters, and returns a URL string for the image:

src
width
quality

import Image from 'next/image'
 
const imageLoader = ({ src, width, quality }) => {
  return `https://example.com/${src}?w=${width}&q=${quality || 75}`
}
 
export default function Page() {
  return (
    <Image
      loader={imageLoader}
      src="me.png"
      alt="Picture of the author"
      width={500}
      height={500}
    />
  )
}
Alternatively, you can use the loaderFile configuration in next.config.js to configure every instance of next/image in your application, without passing a prop.

sizes

Define the sizes of the image at different breakpoints. Used by the browser to choose the most appropriate size from the generated srcset.


import Image from 'next/image'
 
export default function Page() {
  return (
    <div className="grid-element">
      <Image
        fill
        src="/example.png"
        sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
      />
    </div>
  )
}
sizes should be used when:

The image is using the fill prop
CSS is used to make the image responsive
If sizes is missing, the browser assumes the image will be as wide as the viewport (100vw). This can cause unnecessarily large images to be downloaded.

In addition, sizes affects how srcset is generated:

Without sizes: Next.js generates a limited srcset (e.g. 1x, 2x), suitable for fixed-size images.
With sizes: Next.js generates a full srcset (e.g. 640w, 750w, etc.), optimized for responsive layouts.
Learn more about srcset and sizes on web.dev and mdn.
quality

An integer between 1 and 100 that sets the quality of the optimized image. Higher values increase file size and visual fidelity. Lower values reduce file size but may affect sharpness.


// Default quality is 75
<Image quality={75} />
If you’ve configured qualities in next.config.js, the value must match one of the allowed entries.

Good to know: If the original image is already low quality, setting a high quality value will increase the file size without improving appearance.
style

Allows passing CSS styles to the underlying image element.


const imageStyle = {
  borderRadius: '50%',
  border: '1px solid #fff',
  width: '100px',
  height: 'auto',
}
 
export default function ProfileImage() {
  return <Image src="..." style={imageStyle} />
}
Good to know: If you’re using the style prop to set a custom width, be sure to also set height: 'auto' to preserve the image’s aspect ratio.
priority

A boolean that indicates if the image should be preloaded.


// Default priority is false
<Image priority={false} />
true: Preloads the image. Disables lazy loading.
false: Lazy loads the image.
When to use it:

The image is above the fold.
The image is the Largest Contentful Paint (LCP) element.
You want to improve the initial loading performance of your page.
When not to use it:

When the loading prop is used (will trigger warnings).
loading

Controls when the image should start loading.


// Defaults to lazy
<Image loading="lazy" />
lazy: Defer loading the image until it reaches a calculated distance from the viewport.
eager: Load the image immediately, regardless of its position in the page.
Use eager only when you want to ensure the image is loaded immediately.

Learn more about the loading attribute.
placeholder

Specifies a placeholder to use while the image is loading, improving the perceived loading performance.


// defaults to empty
<Image placeholder="empty" />
empty: No placeholder while the image is loading.
blur: Use a blurred version of the image as a placeholder. Must be used with the blurDataURL property.
data:image/...: Uses the Data URL as the placeholder.
Examples:

blur placeholder
Shimmer effect with data URL placeholder prop
Color effect with blurDataURL prop
Learn more about the placeholder attribute.
blurDataURL

A Data URL to be used as a placeholder image before the image successfully loads. Can be automatically set or used with the placeholder="blur" property.


<Image placeholder="blur" blurDataURL="..." />
The image is automatically enlarged and blurred, so a very small image (10px or less) is recommended.

Automatic

If src is a static import of a jpg, png, webp, or avif file, blurDataURL is added automatically—unless the image is animated.

Manually set

If the image is dynamic or remote, you must provide blurDataURL yourself. To generate one, you can use:

A online tool like png-pixel.com
A library like Plaiceholder
A large blurDataURL may hurt performance. Keep it small and simple.

Examples:

Default blurDataURL prop
Color effect with blurDataURL prop
onLoad

A callback function that is invoked once the image is completely loaded and the placeholder has been removed.


<Image onLoad={(e) => console.log(e.target.naturalWidth)} />
The callback function will be called with one argument, the event which has a target that references the underlying <img> element.

onError

A callback function that is invoked if the image fails to load.


<Image onError={(e) => console.error(e.target.id)} />
unoptimized

A boolean that indicates if the image should be optimized. This is useful for images that do not benefit from optimization such as small images (less than 1KB), vector images (SVG), or animated images (GIF).


import Image from 'next/image'
 
const UnoptimizedImage = (props) => {
  // Default is false
  return <Image {...props} unoptimized />
}
true: The source image will be served as-is from the src instead of changing quality, size, or format.
false: The source image will be optimized.
Since Next.js 12.3.0, this prop can be assigned to all images by updating next.config.js with the following configuration:

next.config.js

module.exports = {
  images: {
    unoptimized: true,
  },
}
overrideSrc

When providing the src prop to the <Image> component, both the srcset and src attributes are generated automatically for the resulting <img>.

input.js

<Image src="/profile.jpg" />
output.html

<img
  srcset="
    /_next/image?url=%2Fprofile.jpg&w=640&q=75 1x,
    /_next/image?url=%2Fprofile.jpg&w=828&q=75 2x
  "
  src="/_next/image?url=%2Fprofile.jpg&w=828&q=75"
/>
In some cases, it is not desirable to have the src attribute generated and you may wish to override it using the overrideSrc prop.

For example, when upgrading an existing website from <img> to <Image>, you may wish to maintain the same src attribute for SEO purposes such as image ranking or avoiding recrawl.

input.js

<Image src="/profile.jpg" overrideSrc="/override.jpg" />
output.html

<img
  srcset="
    /_next/image?url=%2Fprofile.jpg&w=640&q=75 1x,
    /_next/image?url=%2Fprofile.jpg&w=828&q=75 2x
  "
  src="/override.jpg"
/>
decoding

A hint to the browser indicating if it should wait for the image to be decoded before presenting other content updates or not.


// Default is async
<Image decoding="async" />
async: Asynchronously decode the image and allow other content to be rendered before it completes.
sync: Synchronously decode the image for atomic presentation with other content.
auto: No preference. The browser chooses the best approach.
Learn more about the decoding attribute.
Other Props

Other properties on the <Image /> component will be passed to the underlying img element with the exception of the following:

srcSet: Use Device Sizes instead.
Deprecated props

onLoadingComplete

Warning: Deprecated in Next.js 14, use onLoad instead.
A callback function that is invoked once the image is completely loaded and the placeholder has been removed.

The callback function will be called with one argument, a reference to the underlying <img> element.


<Image onLoadingComplete={(img) => console.log(img.naturalWidth)} />
Configuration options

You can configure the Image Component in next.config.js. The following options are available:

localPatterns

Use localPatterns in your next.config.js file to allow images from specific local paths to be optimized and block all others.

next.config.js

module.exports = {
  images: {
    localPatterns: [
      {
        pathname: '/assets/images/**',
        search: '',
      },
    ],
  },
}
The example above will ensure the src property of next/image must start with /assets/images/ and must not have a query string. Attempting to optimize any other path will respond with 400 Bad Request error.

remotePatterns

Use remotePatterns in your next.config.js file to allow images from specific external paths and block all others. This ensures that only external images from your account can be served.

next.config.js

module.exports = {
  images: {
    remotePatterns: [new URL('https://example.com/account123/**')],
  },
}
If using a version prior to 15.3.0, you can configure remotePatterns using the object:

next.config.js

module.exports = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'example.com',
        port: '',
        pathname: '/account123/**',
        search: '',
      },
    ],
  },
}
The example above will ensure the src property of next/image must start with https://example.com/account123/ and must not have a query string. Any other protocol, hostname, port, or unmatched path will respond with 400 Bad Request.

Wildcard Patterns:

Wildcard patterns can be used for both pathname and hostname and have the following syntax:

* match a single path segment or subdomain
** match any number of path segments at the end or subdomains at the beginning. This syntax does not work in the middle of the pattern.
next.config.js

module.exports = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: '**.example.com',
        port: '',
        search: '',
      },
    ],
  },
}
This allows subdomains like image.example.com. Query strings and custom ports are still blocked.

Good to know: When omitting protocol, port, pathname, or search then the wildcard ** is implied. This is not recommended because it may allow malicious actors to optimize urls you did not intend.
Query Strings:

You can also restrict query strings using the search property:

next.config.js

module.exports = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'assets.example.com',
        search: '?v=1727111025337',
      },
    ],
  },
}
The example above will ensure the src property of next/image must start with https://assets.example.com and must have the exact query string ?v=1727111025337. Any other protocol or query string will respond with 400 Bad Request.

loaderFile

loaderFiles allows you to use a custom image optimization service instead of Next.js.

next.config.js

module.exports = {
  images: {
    loader: 'custom',
    loaderFile: './my/image/loader.js',
  },
}
The path must be relative to the project root. The file must export a default function that returns a URL string:

my/image/loader.js

export default function myImageLoader({ src, width, quality }) {
  return `https://example.com/${src}?w=${width}&q=${quality || 75}`
}
Example:

Custom Image Loader Configuration
Alternatively, you can use the loader prop to configure each instance of next/image.
path

If you want to change or prefix the default path for the Image Optimization API, you can do so with the path property. The default value for path is /_next/image.

next.config.js

module.exports = {
  images: {
    path: '/my-prefix/_next/image',
  },
}
deviceSizes

deviceSizes allows you to specify a list of device width breakpoints. These widths are used when the next/image component uses sizes prop to ensure the correct image is served for the user's device.

If no configuration is provided, the default below is used:

next.config.js

module.exports = {
  images: {
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  },
}
imageSizes

imageSizes allows you to specify a list of image widths. These widths are concatenated with the array of device sizes to form the full array of sizes used to generate image srcset.

If no configuration is provided, the default below is used:

next.config.js

module.exports = {
  images: {
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },
}
imageSizes is only used for images which provide a sizes prop, which indicates that the image is less than the full width of the screen. Therefore, the sizes in imageSizes should all be smaller than the smallest size in deviceSizes.

qualities

qualities allows you to specify a list of image quality values.

next.config.js

module.exports = {
  images: {
    qualities: [25, 50, 75],
  },
}
In the example above, only three qualities are allowed: 25, 50, and 75. If the quality prop does not match a value in this array, the image will fail with a 400 Bad Request.

formats

formats allows you to specify a list of image formats to be used.

next.config.js

module.exports = {
  images: {
    // Default
    formats: ['image/webp'],
  },
}
Next.js automatically detects the browser's supported image formats via the request's Accept header in order to determine the best output format.

If the Accept header matches more than one of the configured formats, the first match in the array is used. Therefore, the array order matters. If there is no match (or the source image is animated), it will use the original image's format.

You can enable AVIF support, which will fallback to the original format of the src image if the browser does not support AVIF:

next.config.js

module.exports = {
  images: {
    formats: ['image/avif'],
  },
}
Good to know:

We still recommend using WebP for most use cases.
AVIF generally takes 50% longer to encode but it compresses 20% smaller compared to WebP. This means that the first time an image is requested, it will typically be slower, but subsequent requests that are cached will be faster.
If you self-host with a Proxy/CDN in front of Next.js, you must configure the Proxy to forward the Accept header.
minimumCacheTTL

minimumCacheTTL allows you to configure the Time to Live (TTL) in seconds for cached optimized images. In many cases, it's better to use a Static Image Import which will automatically hash the file contents and cache the image forever with a Cache-Control header of immutable.

If no configuration is provided, the default below is used.

next.config.js

module.exports = {
  images: {
    minimumCacheTTL: 60, // 1 minute
  },
}
You can increase the TTL to reduce the number of revalidations and potentially lower cost:

next.config.js

module.exports = {
  images: {
    minimumCacheTTL: 2678400, // 31 days
  },
}
The expiration (or rather Max Age) of the optimized image is defined by either the minimumCacheTTL or the upstream image Cache-Control header, whichever is larger.

If you need to change the caching behavior per image, you can configure headers to set the Cache-Control header on the upstream image (e.g. /some-asset.jpg, not /_next/image itself).

There is no mechanism to invalidate the cache at this time, so its best to keep minimumCacheTTL low. Otherwise you may need to manually change the src prop or delete the cached file <distDir>/cache/images.

disableStaticImages

disableStaticImages allows you to disable static image imports.

The default behavior allows you to import static files such as import icon from './icon.png' and then pass that to the src property. In some cases, you may wish to disable this feature if it conflicts with other plugins that expect the import to behave differently.

You can disable static image imports inside your next.config.js:

next.config.js

module.exports = {
  images: {
    disableStaticImages: true,
  },
}
dangerouslyAllowSVG

dangerouslyAllowSVG allows you to serve SVG images.

next.config.js

module.exports = {
  images: {
    dangerouslyAllowSVG: true,
  },
}
By default, Next.js does not optimize SVG images for a few reasons:

SVG is a vector format meaning it can be resized losslessly.
SVG has many of the same features as HTML/CSS, which can lead to vulnerabilities without proper Content Security Policy (CSP) headers.
We recommend using the unoptimized prop when the src prop is known to be SVG. This happens automatically when src ends with ".svg".


<Image src="/my-image.svg" unoptimized />
In addition, it is strongly recommended to also set contentDispositionType to force the browser to download the image, as well as contentSecurityPolicy to prevent scripts embedded in the image from executing.

next.config.js

module.exports = {
  images: {
    dangerouslyAllowSVG: true,
    contentDispositionType: 'attachment',
    contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
  },
}
contentDispositionType

contentDispositionType allows you to configure the Content-Disposition header.

next.config.js

module.exports = {
  images: {
    contentDispositionType: 'inline',
  },
}
contentSecurityPolicy

contentSecurityPolicy allows you to configure the Content-Security-Policy header for images. This is particularly important when using dangerouslyAllowSVG to prevent scripts embedded in the image from executing.

next.config.js

module.exports = {
  images: {
    contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
  },
}
By default, the loader sets the Content-Disposition header to attachment for added protection since the API can serve arbitrary remote images.

The default value is attachment which forces the browser to download the image when visiting directly. This is particularly important when dangerouslyAllowSVG is true.

You can optionally configure inline to allow the browser to render the image when visiting directly, without downloading it.

Deprecated configuration options

domains

Warning: Deprecated since Next.js 14 in favor of strict remotePatterns in order to protect your application from malicious users. Only use domains if you own all the content served from the domain.
Similar to remotePatterns, the domains configuration can be used to provide a list of allowed hostnames for external images. However, the domains configuration does not support wildcard pattern matching and it cannot restrict protocol, port, or pathname.

Below is an example of the domains property in the next.config.js file:

next.config.js

module.exports = {
  images: {
    domains: ['assets.acme.com'],
  },
}
Functions

getImageProps

The getImageProps function can be used to get the props that would be passed to the underlying <img> element, and instead pass them to another component, style, canvas, etc.


import { getImageProps } from 'next/image'
 
const props = getImageProps({
  src: 'https://example.com/image.jpg',
  alt: 'A scenic mountain view',
  width: 1200,
  height: 800,
})
 
function ImageWithCaption() {
  return (
    <figure>
      <img {...props} />
      <figcaption>A scenic mountain view</figcaption>
    </figure>
  )
}
This also avoid calling React useState() so it can lead to better performance, but it cannot be used with the placeholder prop because the placeholder will never be removed.

Known browser bugs

This next/image component uses browser native lazy loading, which may fallback to eager loading for older browsers before Safari 15.4. When using the blur-up placeholder, older browsers before Safari 12 will fallback to empty placeholder. When using styles with width/height of auto, it is possible to cause Layout Shift on older browsers before Safari 15 that don't preserve the aspect ratio. For more details, see this MDN video.

Safari 15 - 16.3 display a gray border while loading. Safari 16.4 fixed this issue. Possible solutions:
Use CSS @supports (font: -apple-system-body) and (-webkit-appearance: none) { img[loading="lazy"] { clip-path: inset(0.6px) } }
Use priority if the image is above the fold
Firefox 67+ displays a white background while loading. Possible solutions:
Enable AVIF formats
Use placeholder
Examples

Styling images

Styling the Image component is similar to styling a normal <img> element, but there are a few guidelines to keep in mind:

Use className or style, not styled-jsx. In most cases, we recommend using the className prop. This can be an imported CSS Module, a global stylesheet, etc.


import styles from './styles.module.css'
 
export default function MyImage() {
  return <Image className={styles.image} src="/my-image.png" alt="My Image" />
}
You can also use the style prop to assign inline styles.


export default function MyImage() {
  return (
    <Image style={{ borderRadius: '8px' }} src="/my-image.png" alt="My Image" />
  )
}
When using fill, the parent element must have position: relative or display: block. This is necessary for the proper rendering of the image element in that layout mode.


<div style={{ position: 'relative' }}>
  <Image fill src="/my-image.png" alt="My Image" />
</div>
You cannot use styled-jsx because it's scoped to the current component (unless you mark the style as global).

Responsive images with a static export

When you import a static image, Next.js automatically sets its width and height based on the file. You can make the image responsive by setting the style:

Responsive image filling the width and height of its parent container

import Image from 'next/image'
import mountains from '../public/mountains.jpg'
 
export default function Responsive() {
  return (
    <div style={{ display: 'flex', flexDirection: 'column' }}>
      <Image
        alt="Mountains"
        // Importing an image will
        // automatically set the width and height
        src={mountains}
        sizes="100vw"
        // Make the image display full width
        // and preserve its aspect ratio
        style={{
          width: '100%',
          height: 'auto',
        }}
      />
    </div>
  )
}
Responsive images with a remote URL

If the source image is a dynamic or a remote URL, you must provide the width and height props so Next.js can calculate the aspect ratio:

components/page.js

import Image from 'next/image'
 
export default function Page({ photoUrl }) {
  return (
    <Image
      src={photoUrl}
      alt="Picture of the author"
      sizes="100vw"
      style={{
        width: '100%',
        height: 'auto',
      }}
      width={500}
      height={300}
    />
  )
}
Try it out:

Demo the image responsive to viewport
Responsive image with fill

If you don't know the aspect ratio of the image, you can add the fill prop with the objectFit prop set to cover. This will make the image fill the full width of its parent container.

Grid of images filling parent container width

import Image from 'next/image'
import mountains from '../public/mountains.jpg'
 
export default function Fill() {
  return (
    <div
      style={{
        display: 'grid',
        gridGap: '8px',
        gridTemplateColumns: 'repeat(auto-fit, minmax(400px, auto))',
      }}
    >
      <div style={{ position: 'relative', width: '400px' }}>
        <Image
          alt="Mountains"
          src={mountains}
          fill
          sizes="(min-width: 808px) 50vw, 100vw"
          style={{
            objectFit: 'cover', // cover, contain, none
          }}
        />
      </div>
      {/* And more images in the grid... */}
    </div>
  )
}
Background Image

Use the fill prop to make the image cover the entire screen area:

Background image taking full width and height of page

import Image from 'next/image'
import mountains from '../public/mountains.jpg'
 
export default function Background() {
  return (
    <Image
      alt="Mountains"
      src={mountains}
      placeholder="blur"
      quality={100}
      fill
      sizes="100vw"
      style={{
        objectFit: 'cover',
      }}
    />
  )
}
For examples of the Image component used with the various styles, see the Image Component Demo.

Remote images

To use a remote image, the src property should be a URL string.

app/page.js

import Image from 'next/image'
 
export default function Page() {
  return (
    <Image
      src="https://s3.amazonaws.com/my-bucket/profile.png"
      alt="Picture of the author"
      width={500}
      height={500}
    />
  )
}
Since Next.js does not have access to remote files during the build process, you'll need to provide the width, height and optional blurDataURL props manually.

The width and height attributes are used to infer the correct aspect ratio of image and avoid layout shift from the image loading in. The width and height do not determine the rendered size of the image file.

To safely allow optimizing images, define a list of supported URL patterns in next.config.js. Be as specific as possible to prevent malicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket:

next.config.js

module.exports = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 's3.amazonaws.com',
        port: '',
        pathname: '/my-bucket/**',
        search: '',
      },
    ],
  },
}
Theme detection

If you want to display a different image for light and dark mode, you can create a new component that wraps two <Image> components and reveals the correct one based on a CSS media query.

components/theme-image.module.css

.imgDark {
  display: none;
}
 
@media (prefers-color-scheme: dark) {
  .imgLight {
    display: none;
  }
  .imgDark {
    display: unset;
  }
}
components/theme-image.tsx
TypeScript


import styles from './theme-image.module.css'
import Image, { ImageProps } from 'next/image'
 
type Props = Omit<ImageProps, 'src' | 'priority' | 'loading'> & {
  srcLight: string
  srcDark: string
}
 
const ThemeImage = (props: Props) => {
  const { srcLight, srcDark, ...rest } = props
 
  return (
    <>
      <Image {...rest} src={srcLight} className={styles.imgLight} />
      <Image {...rest} src={srcDark} className={styles.imgDark} />
    </>
  )
}
Good to know: The default behavior of loading="lazy" ensures that only the correct image is loaded. You cannot use priority or loading="eager" because that would cause both images to load. Instead, you can use fetchPriority="high".
Try it out:

Demo light/dark mode theme detection
Art direction

If you want to display a different image for mobile and desktop, sometimes called Art Direction, you can provide different src, width, height, and quality props to getImageProps().

app/page.js

import { getImageProps } from 'next/image'
 
export default function Home() {
  const common = { alt: 'Art Direction Example', sizes: '100vw' }
  const {
    props: { srcSet: desktop },
  } = getImageProps({
    ...common,
    width: 1440,
    height: 875,
    quality: 80,
    src: '/desktop.jpg',
  })
  const {
    props: { srcSet: mobile, ...rest },
  } = getImageProps({
    ...common,
    width: 750,
    height: 1334,
    quality: 70,
    src: '/mobile.jpg',
  })
 
  return (
    <picture>
      <source media="(min-width: 1000px)" srcSet={desktop} />
      <source media="(min-width: 500px)" srcSet={mobile} />
      <img {...rest} style={{ width: '100%', height: 'auto' }} />
    </picture>
  )
}
Background CSS

You can even convert the srcSet string to the image-set() CSS function to optimize a background image.

app/page.js

import { getImageProps } from 'next/image'
 
function getBackgroundImage(srcSet = '') {
  const imageSet = srcSet
    .split(', ')
    .map((str) => {
      const [url, dpi] = str.split(' ')
      return `url("${url}") ${dpi}`
    })
    .join(', ')
  return `image-set(${imageSet})`
}
 
export default function Home() {
  const {
    props: { srcSet },
  } = getImageProps({ alt: '', width: 128, height: 128, src: '/img.png' })
  const backgroundImage = getBackgroundImage(srcSet)
  const style = { height: '100vh', width: '100vw', backgroundImage }
 
  return (
    <main style={style}>
      <h1>Hello World</h1>
    </main>
  )
}
Version History

Version	Changes
v15.3.0	remotePatterns added support for array of URL objects.
v15.0.0	contentDispositionType configuration default changed to attachment.
v14.2.23	qualities configuration added.
v14.2.15	decoding prop added and localPatterns configuration added.
v14.2.14	remotePatterns.search prop added.
v14.2.0	overrideSrc prop added.
v14.1.0	getImageProps() is stable.
v14.0.0	onLoadingComplete prop and domains config deprecated.
v13.4.14	placeholder prop support for data:/image...
v13.2.0	contentDispositionType configuration added.
v13.0.6	ref prop added.
v13.0.0	The next/image import was renamed to next/legacy/image. The next/future/image import was renamed to next/image. A codemod is available to safely and automatically rename your imports. <span> wrapper removed. layout, objectFit, objectPosition, lazyBoundary, lazyRoot props removed. alt is required. onLoadingComplete receives reference to img element. Built-in loader config removed.
v12.3.0	remotePatterns and unoptimized configuration is stable.
v12.2.0	Experimental remotePatterns and experimental unoptimized configuration added. layout="raw" removed.
v12.1.1	style prop added. Experimental support for layout="raw" added.
v12.1.0	dangerouslyAllowSVG and contentSecurityPolicy configuration added.
v12.0.9	lazyRoot prop added.
v12.0.0	formats configuration added.
AVIF support added.
Wrapper <div> changed to <span>.
v11.1.0	onLoadingComplete and lazyBoundary props added.
v11.0.0	src prop support for static import.
placeholder prop added.
blurDataURL prop added.
v10.0.5	loader prop added.
v10.0.1	layout prop added.
v10.0.0	next/image introduced.

images

If you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configure next.config.js with the following:

next.config.js

module.exports = {
  images: {
    loader: 'custom',
    loaderFile: './my/image/loader.js',
  },
}
This loaderFile must point to a file relative to the root of your Next.js application. The file must export a default function that returns a string, for example:

my/image/loader.js

'use client'
 
export default function myImageLoader({ src, width, quality }) {
  return `https://example.com/${src}?w=${width}&q=${quality || 75}`
}
Alternatively, you can use the loader prop to pass the function to each instance of next/image.

Good to know: Customizing the image loader file, which accepts a function, requires using Client Components to serialize the provided function.
To learn more about configuring the behavior of the built-in Image Optimization API and the Image Component, see Image Configuration Options for available options.

Example Loader Configuration

Akamai
AWS CloudFront
Cloudinary
Cloudflare
Contentful
Fastly
Gumlet
ImageEngine
Imgix
PixelBin
Sanity
Sirv
Supabase
Thumbor
Imagekit
Nitrogen AIO
Akamai


// Docs: https://techdocs.akamai.com/ivm/reference/test-images-on-demand
export default function akamaiLoader({ src, width, quality }) {
  return `https://example.com/${src}?imwidth=${width}`
}
AWS CloudFront


// Docs: https://aws.amazon.com/developer/application-security-performance/articles/image-optimization
export default function cloudfrontLoader({ src, width, quality }) {
  const url = new URL(`https://example.com${src}`)
  url.searchParams.set('format', 'auto')
  url.searchParams.set('width', width.toString())
  url.searchParams.set('quality', (quality || 75).toString())
  return url.href
}
Cloudinary


// Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg
export default function cloudinaryLoader({ src, width, quality }) {
  const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`]
  return `https://example.com/${params.join(',')}${src}`
}
Cloudflare


// Docs: https://developers.cloudflare.com/images/transform-images
export default function cloudflareLoader({ src, width, quality }) {
  const params = [`width=${width}`, `quality=${quality || 75}`, 'format=auto']
  return `https://example.com/cdn-cgi/image/${params.join(',')}/${src}`
}
Contentful


// Docs: https://www.contentful.com/developers/docs/references/images-api/
export default function contentfulLoader({ src, width, quality }) {
  const url = new URL(`https://example.com${src}`)
  url.searchParams.set('fm', 'webp')
  url.searchParams.set('w', width.toString())
  url.searchParams.set('q', (quality || 75).toString())
  return url.href
}
Fastly


// Docs: https://developer.fastly.com/reference/io/
export default function fastlyLoader({ src, width, quality }) {
  const url = new URL(`https://example.com${src}`)
  url.searchParams.set('auto', 'webp')
  url.searchParams.set('width', width.toString())
  url.searchParams.set('quality', (quality || 75).toString())
  return url.href
}
Gumlet


// Docs: https://docs.gumlet.com/reference/image-transform-size
export default function gumletLoader({ src, width, quality }) {
  const url = new URL(`https://example.com${src}`)
  url.searchParams.set('format', 'auto')
  url.searchParams.set('w', width.toString())
  url.searchParams.set('q', (quality || 75).toString())
  return url.href
}
ImageEngine


// Docs: https://support.imageengine.io/hc/en-us/articles/360058880672-Directives
export default function imageengineLoader({ src, width, quality }) {
  const compression = 100 - (quality || 50)
  const params = [`w_${width}`, `cmpr_${compression}`)]
  return `https://example.com${src}?imgeng=/${params.join('/')`
}
Imgix


// Demo: https://static.imgix.net/daisy.png?format=auto&fit=max&w=300
export default function imgixLoader({ src, width, quality }) {
  const url = new URL(`https://example.com${src}`)
  const params = url.searchParams
  params.set('auto', params.getAll('auto').join(',') || 'format')
  params.set('fit', params.get('fit') || 'max')
  params.set('w', params.get('w') || width.toString())
  params.set('q', (quality || 50).toString())
  return url.href
}
PixelBin


// Doc (Resize): https://www.pixelbin.io/docs/transformations/basic/resize/#width-w
// Doc (Optimise): https://www.pixelbin.io/docs/optimizations/quality/#image-quality-when-delivering
// Doc (Auto Format Delivery): https://www.pixelbin.io/docs/optimizations/format/#automatic-format-selection-with-f_auto-url-parameter
export default function pixelBinLoader({ src, width, quality }) {
  const name = '<your-cloud-name>'
  const opt = `t.resize(w:${width})~t.compress(q:${quality || 75})`
  return `https://cdn.pixelbin.io/v2/${name}/${opt}/${src}?f_auto=true`
}
Sanity


// Docs: https://www.sanity.io/docs/image-urls
export default function sanityLoader({ src, width, quality }) {
  const prj = 'zp7mbokg'
  const dataset = 'production'
  const url = new URL(`https://cdn.sanity.io/images/${prj}/${dataset}${src}`)
  url.searchParams.set('auto', 'format')
  url.searchParams.set('fit', 'max')
  url.searchParams.set('w', width.toString())
  if (quality) {
    url.searchParams.set('q', quality.toString())
  }
  return url.href
}
Sirv


// Docs: https://sirv.com/help/articles/dynamic-imaging/
export default function sirvLoader({ src, width, quality }) {
  const url = new URL(`https://example.com${src}`)
  const params = url.searchParams
  params.set('format', params.getAll('format').join(',') || 'optimal')
  params.set('w', params.get('w') || width.toString())
  params.set('q', (quality || 85).toString())
  return url.href
}
Supabase


// Docs: https://supabase.com/docs/guides/storage/image-transformations#nextjs-loader
export default function supabaseLoader({ src, width, quality }) {
  const url = new URL(`https://example.com${src}`)
  url.searchParams.set('width', width.toString())
  url.searchParams.set('quality', (quality || 75).toString())
  return url.href
}
Thumbor


// Docs: https://thumbor.readthedocs.io/en/latest/
export default function thumborLoader({ src, width, quality }) {
  const params = [`${width}x0`, `filters:quality(${quality || 75})`]
  return `https://example.com${params.join('/')}${src}`
}
ImageKit.io


// Docs: https://imagekit.io/docs/image-transformation
export default function imageKitLoader({ src, width, quality }) {
  const params = [`w-${width}`, `q-${quality || 80}`]
  return `https://ik.imagekit.io/your_imagekit_id/${src}?tr=${params.join(',')}`
}
Nitrogen AIO


// Docs: https://docs.n7.io/aio/intergrations/
export default function aioLoader({ src, width, quality }) {
  const url = new URL(src, window.location.href)
  const params = url.searchParams
  const aioParams = params.getAll('aio')
  aioParams.push(`w-${width}`)
  if (quality) {
    aioParams.push(`q-${quality.toString()}`)
  }
  params.set('aio', aioParams.join(';'))
  return url.href
}

rewrites

Rewrites allow you to map an incoming request path to a different destination path.

Rewrites act as a URL proxy and mask the destination path, making it appear the user hasn't changed their location on the site. In contrast, redirects will reroute to a new page and show the URL changes.

To use rewrites you can use the rewrites key in next.config.js:

next.config.js

module.exports = {
  async rewrites() {
    return [
      {
        source: '/about',
        destination: '/',
      },
    ]
  },
}
Rewrites are applied to client-side routing. In the example above, navigating to <Link href="/about"> will serve content from / while keeping the URL as /about.

rewrites is an async function that expects to return either an array or an object of arrays (see below) holding objects with source and destination properties:

source: String - is the incoming request path pattern.
destination: String is the path you want to route to.
basePath: false or undefined - if false the basePath won't be included when matching, can be used for external rewrites only.
locale: false or undefined - whether the locale should not be included when matching.
has is an array of has objects with the type, key and value properties.
missing is an array of missing objects with the type, key and value properties.
When the rewrites function returns an array, rewrites are applied after checking the filesystem (pages and /public files) and before dynamic routes. When the rewrites function returns an object of arrays with a specific shape, this behavior can be changed and more finely controlled, as of v10.1 of Next.js:

next.config.js

module.exports = {
  async rewrites() {
    return {
      beforeFiles: [
        // These rewrites are checked after headers/redirects
        // and before all files including _next/public files which
        // allows overriding page files
        {
          source: '/some-page',
          destination: '/somewhere-else',
          has: [{ type: 'query', key: 'overrideMe' }],
        },
      ],
      afterFiles: [
        // These rewrites are checked after pages/public files
        // are checked but before dynamic routes
        {
          source: '/non-existent',
          destination: '/somewhere-else',
        },
      ],
      fallback: [
        // These rewrites are checked after both pages/public files
        // and dynamic routes are checked
        {
          source: '/:path*',
          destination: `https://my-old-site.com/:path*`,
        },
      ],
    }
  },
}
Good to know: rewrites in beforeFiles do not check the filesystem/dynamic routes immediately after matching a source, they continue until all beforeFiles have been checked.
The order Next.js routes are checked is:

headers are checked/applied
redirects are checked/applied
beforeFiles rewrites are checked/applied
static files from the public directory, _next/static files, and non-dynamic pages are checked/served
afterFiles rewrites are checked/applied, if one of these rewrites is matched we check dynamic routes/static files after each match
fallback rewrites are checked/applied, these are applied before rendering the 404 page and after dynamic routes/all static assets have been checked. If you use fallback: true/'blocking' in getStaticPaths, the fallback rewrites defined in your next.config.js will not be run.
Rewrite parameters

When using parameters in a rewrite the parameters will be passed in the query by default when none of the parameters are used in the destination.

next.config.js

module.exports = {
  async rewrites() {
    return [
      {
        source: '/old-about/:path*',
        destination: '/about', // The :path parameter isn't used here so will be automatically passed in the query
      },
    ]
  },
}
If a parameter is used in the destination none of the parameters will be automatically passed in the query.

next.config.js

module.exports = {
  async rewrites() {
    return [
      {
        source: '/docs/:path*',
        destination: '/:path*', // The :path parameter is used here so will not be automatically passed in the query
      },
    ]
  },
}
You can still pass the parameters manually in the query if one is already used in the destination by specifying the query in the destination.

next.config.js

module.exports = {
  async rewrites() {
    return [
      {
        source: '/:first/:second',
        destination: '/:first?second=:second',
        // Since the :first parameter is used in the destination the :second parameter
        // will not automatically be added in the query although we can manually add it
        // as shown above
      },
    ]
  },
}
Good to know: Static pages from Automatic Static Optimization or prerendering params from rewrites will be parsed on the client after hydration and provided in the query.
Path Matching

Path matches are allowed, for example /blog/:slug will match /blog/hello-world (no nested paths):

next.config.js

module.exports = {
  async rewrites() {
    return [
      {
        source: '/blog/:slug',
        destination: '/news/:slug', // Matched parameters can be used in the destination
      },
    ]
  },
}
Wildcard Path Matching

To match a wildcard path you can use * after a parameter, for example /blog/:slug* will match /blog/a/b/c/d/hello-world:

next.config.js

module.exports = {
  async rewrites() {
    return [
      {
        source: '/blog/:slug*',
        destination: '/news/:slug*', // Matched parameters can be used in the destination
      },
    ]
  },
}
Regex Path Matching

To match a regex path you can wrap the regex in parenthesis after a parameter, for example /blog/:slug(\\d{1,}) will match /blog/123 but not /blog/abc:

next.config.js

module.exports = {
  async rewrites() {
    return [
      {
        source: '/old-blog/:post(\\d{1,})',
        destination: '/blog/:post', // Matched parameters can be used in the destination
      },
    ]
  },
}
The following characters (, ), {, }, [, ], |, \, ^, ., :, *, +, -, ?, $ are used for regex path matching, so when used in the source as non-special values they must be escaped by adding \\ before them:

next.config.js

module.exports = {
  async rewrites() {
    return [
      {
        // this will match `/english(default)/something` being requested
        source: '/english\\(default\\)/:slug',
        destination: '/en-us/:slug',
      },
    ]
  },
}
Header, Cookie, and Query Matching

To only match a rewrite when header, cookie, or query values also match the has field or don't match the missing field can be used. Both the source and all has items must match and all missing items must not match for the rewrite to be applied.

has and missing items can have the following fields:

type: String - must be either header, cookie, host, or query.
key: String - the key from the selected type to match against.
value: String or undefined - the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the value first-(?<paramName>.*) is used for first-second then second will be usable in the destination with :paramName.
next.config.js

module.exports = {
  async rewrites() {
    return [
      // if the header `x-rewrite-me` is present,
      // this rewrite will be applied
      {
        source: '/:path*',
        has: [
          {
            type: 'header',
            key: 'x-rewrite-me',
          },
        ],
        destination: '/another-page',
      },
      // if the header `x-rewrite-me` is not present,
      // this rewrite will be applied
      {
        source: '/:path*',
        missing: [
          {
            type: 'header',
            key: 'x-rewrite-me',
          },
        ],
        destination: '/another-page',
      },
      // if the source, query, and cookie are matched,
      // this rewrite will be applied
      {
        source: '/specific/:path*',
        has: [
          {
            type: 'query',
            key: 'page',
            // the page value will not be available in the
            // destination since value is provided and doesn't
            // use a named capture group e.g. (?<page>home)
            value: 'home',
          },
          {
            type: 'cookie',
            key: 'authorized',
            value: 'true',
          },
        ],
        destination: '/:path*/home',
      },
      // if the header `x-authorized` is present and
      // contains a matching value, this rewrite will be applied
      {
        source: '/:path*',
        has: [
          {
            type: 'header',
            key: 'x-authorized',
            value: '(?<authorized>yes|true)',
          },
        ],
        destination: '/home?authorized=:authorized',
      },
      // if the host is `example.com`,
      // this rewrite will be applied
      {
        source: '/:path*',
        has: [
          {
            type: 'host',
            value: 'example.com',
          },
        ],
        destination: '/another-page',
      },
    ]
  },
}
Rewriting to an external URL

Rewrites allow you to rewrite to an external URL. This is especially useful for incrementally adopting Next.js. The following is an example rewrite for redirecting the /blog route of your main app to an external site.

next.config.js

module.exports = {
  async rewrites() {
    return [
      {
        source: '/blog',
        destination: 'https://example.com/blog',
      },
      {
        source: '/blog/:slug',
        destination: 'https://example.com/blog/:slug', // Matched parameters can be used in the destination
      },
    ]
  },
}
If you're using trailingSlash: true, you also need to insert a trailing slash in the source parameter. If the destination server is also expecting a trailing slash it should be included in the destination parameter as well.

next.config.js

module.exports = {
  trailingSlash: true,
  async rewrites() {
    return [
      {
        source: '/blog/',
        destination: 'https://example.com/blog/',
      },
      {
        source: '/blog/:path*/',
        destination: 'https://example.com/blog/:path*/',
      },
    ]
  },
}
Incremental adoption of Next.js

You can also have Next.js fall back to proxying to an existing website after checking all Next.js routes.

This way you don't have to change the rewrites configuration when migrating more pages to Next.js

next.config.js

module.exports = {
  async rewrites() {
    return {
      fallback: [
        {
          source: '/:path*',
          destination: `https://custom-routes-proxying-endpoint.vercel.app/:path*`,
        },
      ],
    }
  },
}
Rewrites with basePath support

When leveraging basePath support with rewrites each source and destination is automatically prefixed with the basePath unless you add basePath: false to the rewrite:

next.config.js

module.exports = {
  basePath: '/docs',
 
  async rewrites() {
    return [
      {
        source: '/with-basePath', // automatically becomes /docs/with-basePath
        destination: '/another', // automatically becomes /docs/another
      },
      {
        // does not add /docs to /without-basePath since basePath: false is set
        // Note: this can not be used for internal rewrites e.g. `destination: '/another'`
        source: '/without-basePath',
        destination: 'https://example.com',
        basePath: false,
      },
    ]
  },
}
Version History

Version	Changes
v13.3.0	missing added.
v10.2.0	has added.
v9.5.0	Headers added.

Media manager

Introduction
Configuring external storage
Media configuration options
Defining media fields
Attaching media fields to a model
Displaying media on your site
#Introduction

TastyIgniter provides a flexible and configurable media management system. The Media Manager allows you to upload, organize, and manage media files. By default, Media Manager works with the storage/app/public/media directory. It is possible to use external storages such as Amazon S3.

#Configuring external storage

To use the S3 driver, install the required dependencies via Composer.

composer require league/flysystem-aws-s3-v3 "^3.0" --with-all-dependencies
Configure the S3 driver using the .env file.

FILESYSTEM_DISK=s3 AWS_ACCESS_KEY_ID=<your-key-id> AWS_SECRET_ACCESS_KEY=<your-secret-access-key> AWS_DEFAULT_REGION=us-east-1 AWS_BUCKET=<your-bucket-name> AWS_USE_PATH_STYLE_ENDPOINT=false
Using S3 compatible storage services like DigitalOcean Spaces, configure the driver using the .env file.

AWS_ENDPOINT=https://nyc3.digitaloceanspaces.com
#Media configuration options

The Media Manager in TastyIgniter can be configured according to your preference. You can do this by editing the config/igniter-system.php file.

The config/igniter-system.php configuration file contains several options that allow you to customize the behavior of the Media Manager:

media: This section contains the configuration options for the media uploaded files.

disk: This option specifies the storage disk that the Media Manager should use for uploads. By default, it uses the public disk.
folder: This option specifies the folder within the storage disk where the media files should be stored. By default, it is set to media/uploads/.
path: This option specifies the path to prepend to the file name when generating the file URL. By default, it is set to media/uploads/.
max_upload_size: This option specifies the maximum size (in kilobytes) of the files that can be uploaded through the Media Manager. By default, it is set to 1500 (1.5 MB).
enable_uploads: This option allows you to enable or disable file uploads. By default, it is set to true.
enable_new_folder: This option allows you to enable or disable the creation of new folders through the Media Manager. By default, it is set to true.
enable_rename: This option allows you to enable or disable the renaming of files and folders through the Media Manager. By default, it is set to true.
enable_move: This option allows you to enable or disable the moving of files and folders through the Media Manager. By default, it is set to true.
enable_copy: This option allows you to enable or disable the copying of files and folders through the Media Manager. By default, it is set to true.
enable_delete: This option allows you to enable or disable the deletion of files and folders through the Media Manager. By default, it is set to true.
attachment: This section contains the configuration options for the attachment files.

disk: This option specifies the storage disk that the Media Manager should use for attachments. By default, it uses the public disk.
folder: This option specifies the folder within the storage disk where the attachment files should be stored. By default, it is set to media/attachments/.
path: This option specifies the path to prepend to the file name when generating the file URL. By default, it is set to media/attachments/.
These options provide a high level of control over how media files are handled in your application. You can customize these options according to your application's requirements.

To publish the config file to config/igniter-system.php run:

php artisan vendor:publish --tag="igniter-config"
For more information on configuring external storage, check out Laravel's filesystem docs.

#Defining media fields

Media fields allow you to choose or attach images, videos, and other media files from the library. You can define media fields in the configuration file of your model and use them in forms.

To use a media field in a form, you can use the mediafinder form widget. For a single image field, you can use the mediafinder form widget with the isMulti set to false:

return [
    'fields' => [
        'featured_image' => [
            'label' => 'Featured Image',
            'type' => 'mediafinder',
            'isMulti' => false,
        ],
    ],
];
For a multiple images field, you can use the mediafinder form widget with the isMulti set to true:

return [
    'fields' => [
        'gallery_images' => [
            'label' => 'Gallery Images',
            'type' => 'mediafinder',
            'isMulti' => true,
        ],
    ],
];
#Attaching media fields to a model

Media files can be attached to a model using the Igniter\Flame\Database\Attach\HasMedia trait and defining the $mediable property. For example, to attach single media files to the gallery_images field of MenuItem model, you can use the following code

class MenuItem extends Model
{
    use \Igniter\Flame\Database\Attach\HasMedia;

    public array $mediable = ['featured_image'];
}
To attach multiple media files to the gallery_images field of MenuItem model, you can use the following code:

class MenuItem extends Model
{
    use \Igniter\Flame\Database\Attach\HasMedia;

    public array $mediable = ['gallery_images' => ['multiple' => true]];
}
#Displaying media on your site

To display a media file in a template, you can use the media method of the media model.

For a single media field, you can display the image using the following code:

<img src="{{ $model->featured_image }}" alt="Featured Image">
For a multiple media field, you can display the images using a loop:

@foreach($model->gallery_images as $media)
    <img src="{{ $media }}" alt="Gallery Image">
@endforeach
For a single attached media field, you can display the image using the following code:

<img src="{{ $model->featured_image->getThumb() }}" alt="Featured Image">
For a multiple attached media field, you can display the images using a loop:

@foreach($model->gallery_images as $media)
    <img src="{{ $media->getThumb() }}" alt="Gallery Image">
@endforeach
The getThumb method accepts an optional parameter to specify the size of the thumbnail. For example, to get a thumbnail of size 200x200, you can use:

<img src="{{ $media->getThumb([
    'width' => 200,
    'height' => 200,
]) }}" alt="Gallery Image">

nstallation

You can install the extension via composer by running this command:

composer require tastyigniter/ti-ext-api -W
You may install Laravel Sanctum via the install:api Artisan command to set up the necessary database tables and create a personal access client:

php artisan install:api
Run the database migrations to create the required tables.

php artisan igniter:up
#Getting started

The API extension provides a REST API for TastyIgniter, allowing you to interact with the system programmatically. It uses Laravel Sanctum for authentication and authorization.

From your TastyIgniter Admin, navigate to Tools > APIs to configure the API endpoints.

#Consuming the API

The API extension provides endpoints for all core TastyIgniter resources. You can interact with these endpoints using standard HTTP methods (GET, POST, PUT, DELETE).

Here's an example of how to retrieve all menu items:

curl -X GET https://your-tastyigniter-site.com/api/menus
#Generating access tokens

If you choose to restrict access to the API to customers, admin or both, you will need to generate a token for each user or customer you want to be able to access the API.

Tokens can be generated for admin and customers users by running the following command, you can also use the --admin option to generate an admin token, a customer token is generated by default:

php artisan igniter:api-token --name=my_device --email=my_email
Or, by sending a POST request to: https://your-tastyigniter-site.com/api/token

curl -X POST --data "username=my_user&password=my_password&device_name=my_device" https://your-tastyigniter-site.com/api/token
The post data should contain the following fields:

field	value
is_admin	Set to 1 to generate an admin token, 0 for a customer token
email	The email of the customer, required when generating for customer
password	The admin user's password
device_name	A unique identifier for the device making the request
abilities	An optional array of abilities to restrict the token to (e.g. orders.*)
If token generation is successful, you will receive a JSON payload in the format:

{
  "status_code":201,
  "token":"your-api-token"
}
#Using access tokens

Tokens should be passed in the Authorization header with every request to a restricted endpoint. For example:

curl -i -X GET -H "Accept: application/json" -H "Content-Type: application/json" -H "Authorization: Bearer your-api-token" https://your-tastyigniter-site.com/api/orders
If you are using an Apache server, you need to modify your .htaccess file to ensure tokens are passed correctly. Add the following lines to your .htaccess file:

RewriteCond %{HTTP:Authorization} ^(.*)
RewriteRule .* - [e=HTTP_AUTHORIZATION:%1]
These lines instruct Apache to capture the Authorization HTTP header and pass it as an environment variable HTTP_AUTHORIZATION, allowing Laravel Sanctum to access the token and authenticate the request.

#Usage

This section covers how to integrate the API extension into your own extension if you're building an extension that provides API resources. The API extension provides a simple API for defining and managing resources, allowing you to create, read, update, and delete data in TastyIgniter.

#Defining resource controllers

You can extend the API by adding new endpoints in your own extensions. Each resource should have a corresponding:

controller - handles the request and response
transformer - transforms the response data
repository - handles the data retrieval and manipulation
request - validates the request data
A resource controller class is typically stored in the src/ApiResources directory of an extension. The resource controller class should extend the Igniter\Api\Classes\ApiController class, implements the Igniter\Api\Http\Actions\RestController class and define the $restConfig property with the configuration for the resource.

Here's an example of a custom API resource controller:

namespace Author\Extension\ApiResources;

use Igniter\Api\Classes\ApiController;
use Igniter\Api\Http\Actions\RestController;
use Author\Extension\ApiResources\Repositories\MenuRepository;
use Author\Extension\ApiResources\Transformers\MenuTransformer;
use Author\Extension\ApiResources\Requests\MenuRequest;

class Menus extends ApiController
{
    public array $implement = [RestController::class];

    public array $restConfig = [
        'actions' => [
            'index' => [
                'pageLimit' => 20,
            ],
            'store' => [],
            'show' => [],
            'update' => [],
            'destroy' => [],
        ],
        'request' => MenuRequest::class,
        'repository' => MenuRepository::class,
        'transformer' => MenuTransformer::class,
    ];

    protected string|array $requiredAbilities = ['menus:*'];
}
The $implement property should contain the RestController class to enable the REST controller actions.
#Defining resource transformers

Response are transformed using Fractal.

A resource transformer class is typically stored in the src/ApiResources/Transformers directory of an extension. The transformer class is a simple class that extends League\Fractal\TransformerAbstract and contains a transform method that returns the transformed data.

Here is an example of a Resource Transformer:

namespace Author\Extension\ApiResources\Transformers;

use League\Fractal\TransformerAbstract;

class MenuTransformer extends TransformerAbstract
{
  public function transform(Menu $menu): array
  {
    return $menu->toArray();
  }
}
#Defining resource repositories

A resource repository class is typically stored in the src/ApiResources/Repositories directory. The repository class should extend the Igniter\Api\Classes\AbstractRepository class and define the model class for the resource.

Here is an example of a Resource Repository:

namespace Author\Extension\ApiResources\Repositories;

use Igniter\Api\Classes\AbstractRepository;
use Author\Extension\Models\Menu;

class MenuRepository extends AbstractRepository
{
    protected ?string $modelClass = Menu::class;
}
#Defining resource requests

A resource request class is typically stored in the src/ApiResources/Requests directory. The request class should extend the Igniter\System\Classes\FormRequest class and define the validation rules for the resource.

Here is an example of a Resource Request:

namespace Author\Extension\ApiResources\Requests;

use Igniter\System\Classes\FormRequest;

class MenuRequest extends FormRequest
{
    public function rules(): array
    {
        return [
            'menu_name' => 'required',
        ];
    }
}
For more information on using Form Requests, see the Form Requests documentation.

#Register API resources

After the resource classes has been created, add it to routes by registering a new api resource in the registerApiResources method of your extension class. The registerApiResources method should return an array of resources where the key is the resource name and the value is an array of resource configuration.

public function registerApiResources(): array
{
    return [
        'menus' => [
            'name' => 'Menus',
            'description' => 'Description of this API resource',
            'controller' => \Author\Extension\ApiResources\Menus::class,
            'actions' => ['destroy:admin']
        ],
    ];
}
These are the available options for the resource configuration:

name - The name of the resource
description - A brief description of the resource
controller - The controller class for the resource
actions - An array of actions to enable for the resource. You can predefine authorization context for each action by adding the context. For example to make the delete endpoint only accessible to admin users, ['destroy:admin']
#Overriding API actions

You can override the default behavior of API actions (verbs) with your own logic by defining a method in the controller class with the action name. For example, to override the index action:

public function index(): Response
{
    // Your custom logic here

    // Call the ListController action index() method
    return $this->asExtension('RestController')->index();
}
#Permissions

The API extension registers the following permission:

Igniter.Api.Manage: Control who can access the API in the admin area.
For more on restricting access to the admin area, see the TastyIgniter Permissions documentation.

use Igniter\User\Facades\AdminAuth;

if (AdminAuth::getUser()->hasPermission('Igniter.Api.Manage')) {
    // Do something...
}
#